#+Title Using Django
* reference
https://docs.djangoproject.com/en/2.1/topics/
* How to install Django
** Install Python
** Install Apache and mod_wsgi
** Get your database running
** Install the Django code
*** Installing an official release with pip
*** Installing a distribution-specific package
*** Installing the development version
* Models and databases
** Models
django.db.models.Model
*** Quick example
*** Using models
add new apps to INSTALLED_APPS
python manage.py migrate
python manage.py makemigrations

*** Fields
**** Field types
**** Field options
null
blank
choices
default
help_text
primary_key
unique
**** Automatic primary key fields
id = models.AutoField(primary_key=True)
**** Verbose field names
**** Relationships
**** Many-to-one relationships
django.db.models.ForeignKey.
**** Many-to-many relationships
ManyToManyField
**** Extra fields on many-to-many relationships
through
symmetrical
**** One-to-one relationships
OneToOneField
parent_link
**** example
>>> hasattr(p2, 'restaurant')
**** Models across files
**** Field name restrictions
Python reserved word
more than one underscore in a row
**** Custom field types
*** Meta options
class Meta in model.
*** Model attributes
objects
no custom Manager is defined, the default name is objects.
*** Model methods
 __str__()
 get_absolute_url()
**** Overriding predefined model methods
**** Executing custom SQL
*** Model inheritance
**** Abstract base classes
 class CommonInfo(models.Model):
     ....

     class Meta:
         abstract = True
***** Meta inheritance
***** Be careful with related_name and related_query_name¶
 %(class)
 %(app_label)
**** Multi-table inheritance
***** Meta and multi-table inheritance
***** Inheritance and reverse relations
***** Specifying the parent link field
 create your own OneToOneField and set parent_link=True.
**** Proxy models
 class MyPerson(Person):
     class Meta:
         proxy = True
***** QuerySets still return the model that was requested
***** Base class restrictions
 A proxy model must inherit from exactly one non-abstract model class
***** Proxy model managers
***** Differences between proxy inheritance and unmanaged models¶
 Meta.managed=False. 
 Meta.proxy=True.
**** Multiple inheritance
**** Field name “hiding” is not permitted
 removed by setting field_name = None.
*** Organizing models in a package
 myapp/models/__init__.py
** Making queries
*** Creating objects
save()
*** Saving changes to objects
save()
**** Saving ForeignKey and ManyToManyField fields
*** Retrieving objects
construct a QuerySet via a Manager on your model class.
Blog.objects.all() 
**** Retrieving all objects
modelClass.objects.all()
**** Retrieving specific objects with filters
filter(**kwargs)
exclude(**kwargs)
***** Chaining filters
***** Filtered QuerySets are unique
***** QuerySets are lazy
**** Retrieving a single object with get()
>>> one_entry = Entry.objects.get(pk=1)
**** Other QuerySet methods
**** Limiting QuerySets
>>> Entry.objects.all()[:5]

“step” parameter. evaluate the query.
>>> Entry.objects.all()[:10:2]

>>> Entry.objects.order_by('headline')[0]
**** Field lookups
 field__lookuptype=value
lte
exact
iexact
contains
icontains
startswith, endswith
istartswith, iendswith
**** Lookups that span relationships
span relationships.
reverse” relationship.
***** Spanning multi-valued relationships
consistent way of processing filter() calls.
Successive filter() calls. 
pply to any object linked to the primary model, 
not necessarily those objects that were selected by an earlier filter() call.

Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)
excute follows statements, quals to above, this is important.
>>> qs = Blog.objects.filter(entry__headline__contains='Lennon')
>>> qs = Blog.objects.filter(entry__pub_date__year=2008)

**** Filters can reference fields on the model
F expressions
**** The pk lookup shortcut
pk
**** Escaping percent signs and underscores in LIKE statements¶
**** Caching and QuerySets¶
***** When QuerySets are not cached¶
*** Complex lookups with Q objects
from django.db.models import Q
Q(question__startswith='What')
*** Comparing objects
==
*** Deleting objects
delete()
*** Copying model instances
pk to none
*** Updating multiple objects at once
QuerySet.update()
*** Related objects
b.entry_set.all()
**** One-to-many relationships
***** Forward
***** Following relationships “backward”
QuerySets
***** Using a custom reverse manager
***** Additional methods to handle related objects
add(obj1, obj2, ...)
create(**kwargs)
remove(obj1, obj2, ...)
clear()
set(objs)
**** Many-to-many relationships
_set
**** One-to-one relationships
**** How are the backward relationships possible?
app registry
INSTALLED_APPS
**** Queries over related objects
*** Falling back to raw SQL
** Aggregation
*** Cheat sheet
*** Generating aggregates over a QuerySet
>>> from django.db.models import Avg, Max, Min
return Dictionary QuerySet.aggregate()
*** Generating aggregates for each item in a QuerySet
return QruerySet QuerySet.annotate()
**** Combining multiple aggregations
Book.objects.annotate(Count('authors'), Count('store'))
Book.objects.annotate(Count('authors', distinct=True), Count('store', distinct=True))
*** Joins and aggregates
double underscore notation
**** Following relationships backwards
*** Aggregations and other QuerySet clauses
**** filter() and exclude()
***** Filtering on annotations
***** Order of annotate() and filter() clauses

